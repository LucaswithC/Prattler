// /*******************************************************************
// * Posts.js
// * Generated by Backendless Corp.
// ********************************************************************/

import pb from "../connect";

const Utils = {
  isObject: (obj) => obj === Object(obj),
  isString: (obj) => Object.prototype.toString.call(obj).slice(8, -1) === "String",
  isNumber: (obj) => Object.prototype.toString.call(obj).slice(8, -1) === "Number",
  isBoolean: (obj) => Object.prototype.toString.call(obj).slice(8, -1) === "Boolean",
  isDate: (obj) => Object.prototype.toString.call(obj).slice(8, -1) === "Date",
};

async function addPost(postInfo) {
  return new Promise(async (resolve, reject) => {
    if (!Utils.isObject(postInfo)) {
      return reject(new Error('Invalid value for argument "postInfo". Must be object value'));
    }

    if (!pb.authStore?.model) {
      return reject(new Error("You need to be logged in"));
    }

    if (postInfo?.comment) {
      await Promise.all([pb.collection("users").getOne(pb.authStore.model.id), pb.collection("posts").getOne(postInfo.comment)]).then((val) => {
        let [user, origPost] = val;
        if (origPost.canReply === "followers" && !user.follows.includes(origPost.author) && user.id !== origPost.id) {
          return reject(new Error("Only followers can comment"));
        }
      });
    }

    let data = new FormData();

    data.append("text", postInfo.text);
    data.append("canReply", postInfo.reply);
    if (postInfo.images.length > 4) {
      return reject(new Error("You cant upload more than 4 pictures"));
    }
    for (let image of postInfo.images) {
      if (image.size > 4194304) {
        return reject(new Error(image.name + " is too big."));
      }
      data.append("images", image);
    }
    data.append("totalLikes", 0);
    data.append("totalReposts", 0);
    data.append("totalComments", 0);
    data.append("totalSaves", 0);
    data.append("author", pb.authStore.model.id);

    let newPost = await pb
      .collection("posts")
      .create(data)
      .then((res) => res)
      .catch((err) => reject(err));

    let feedData = {
      type: postInfo?.comment ? "comment" : "post",
      author: pb.authStore.model.id,
      post: newPost.id,
    };
    if (postInfo?.comment) {
      feedData.comment = postInfo.comment;
    }

    let newFeed = await pb
      .collection("feed")
      .create(feedData, {
        expand: "post,comment,author,post.author,comment.author",
      })
      .then((res) => res)
      .catch((err) => reject(err));

    if (postInfo?.comment) {
      await pb
        .collection("posts")
        .update(postInfo.comment, { "totalComments+": 1 })
        .catch((err) => reject(err));
    }

    let hashtags = postInfo.text.match(/#\w+/gi);

    if (hashtags?.length > 0) {
      hashtags = hashtags.map((h) => h.toLowerCase());
      let tags = await pb.collection("hashtags").getFullList(200, {
        filter: hashtags.map((t) => `name = "${t}"`).join(" || "),
      });

      for (let tag of hashtags) {
        let index = tags?.findIndex((t) => t.name === tag);
        if (index >= 0) {
          await pb.collection("hashtags").update(tags[index].id, {
            "amount+": 1,
          });
        } else {
          await pb.collection("hashtags").create({
            name: tag,
            amount: 1,
          });
        }
      }
    }

    return resolve(newFeed);
  });
}

function hidePost(feedId) {
  return new Promise(async (resolve, reject) => {
    if (!Utils.isString(feedId)) {
      return reject(new Error('Invalid value for argument "postId". Must be string value'));
    }

    if (!pb.authStore?.model) {
      return reject(new Error("You need to be logged in to remove your posts"));
    }

    let originalPost = await pb.collection("feed").getOne(feedId, {
      expand: "post",
    });

    if (pb.authStore?.model?.id !== originalPost.expand.post.author) {
      return reject(new Error("Only the author can remove a post"));
    }

    let removedPost = pb
      .collection("posts")
      .update(originalPost.post, {
        hidden: true,
      })
      .then((res) => res)
      .catch((err) => reject(err));

    if (originalPost.comment) {
      pb.collection("posts").update(originalPost.comment, {
        "totalComments-": 1,
      });
    }

    let hashtags = originalPost.expand.post.text.match(/#\w+/gi);

    if (hashtags?.length > 0) {
      let allTags = await pb.collection("hashtags").getFullList(200, {
        filter: hashtags.map((t) => `name = "${t}"`).join(" || "),
      });
      for (let tag of allTags) {
        pb.collection("hashtags").update(tag.id, {
          "amount-": 1,
          $autoCancel: false,
        });
      }
    }

    return resolve(removedPost);
  });
}

function getAll(filter, pageSize = 20, pageOffset = 1) {
  return new Promise((resolve, reject) => {
    if (!Utils.isObject(filter)) {
      return reject(new Error('Invalid value for argument "filter". Must be object value'));
    }

    getPosts(filter, pageSize, pageOffset)
      .then((res) => resolve(res))
      .catch((err) => reject(err));
  });
}

function getFollowingPosts(pageSize = 20, pageOffset = 1) {
  return new Promise((resolve, reject) => {
    if (!pb.authStore?.model) {
      return reject(new Error("You need to be logged in"));
    }

    let filter = [...pb.authStore.model.follows, pb.authStore.model.id].map((f) => `author = "${f}"`).join(" || ");
    getPosts({ filter: ["(" + filter + ")"], sort: "-created" }, pageSize, pageOffset)
      .then((res) => resolve(res))
      .catch((err) => reject(err));
  });
}

function getSinglePost(postId, isComment = false) {
  return new Promise(async (resolve, reject) => {
    if (!Utils.isString(postId)) {
      return reject(new Error('Invalid value for argument "postId". Must be string value'));
    }

    let singlePost = isComment
      ? await getPosts({ filter: [`((type = "post" || type = "comment") && post = "${postId}")`] }, 1, 1)
      : await getPosts({ filter: [`id = "${postId}"`] }, 1, 1);

    if (singlePost.totalItems > 0) {
      return resolve(singlePost.items[0]);
    } else {
      return reject(new Error("Post not found"));
    }
  });
}

function getPostComments(postId, sort, pageSize, pageOffset) {
  return new Promise((resolve, reject) => {
    if (!Utils.isString(postId)) {
      return reject(new Error('Invalid value for argument "postId". Must be string value'));
    }

    if (!Utils.isString(sort)) {
      return reject(new Error('Invalid value for argument "sort". Must be string value'));
    }

    if (!Utils.isNumber(pageSize)) {
      return reject(new Error('Invalid value for argument "pageSize". Must be object value'));
    }

    if (!Utils.isNumber(pageOffset)) {
      return reject(new Error('Invalid value for argument "pageOffset". Must be object value'));
    }

    getAll(
      {
        filter: ['type = "comment"', `comment = "${postId}"`],
        sort: sort,
      },
      pageSize,
      pageOffset
    )
      .then((res) => resolve(res))
      .catch((err) => reject(err));
  });
}

function likePost(postId) {
  return new Promise(async (resolve, reject) => {
    if (!Utils.isString(postId)) {
      return reject(new Error('Invalid value for argument "postId". Must be string value'));
    }

    if (!pb.authStore?.model) {
      return reject(new Error("You need to be logged in to like a post"));
    }

    let hasLiked = await pb.collection("feed").getList(1, 1, {
      filter: 'type = "like" && author = "' + pb.authStore.model.id + '" && post = "' + postId + '"',
    });

    if (hasLiked.totalItems > 0) {
      return reject(new Error("You already liked this post"));
    }

    pb.collection("feed")
      .create({
        type: "like",
        author: pb.authStore.model.id,
        post: postId,
      })
      .then((res) => {
        pb.collection("posts")
          .update(postId, {
            "totalLikes+": 1,
          })
          .then((res) => resolve(res))
          .catch((err) => reject(err));
      })
      .catch((err) => reject(err));
  });
}

function unlikePost(postId) {
  return new Promise(async (resolve, reject) => {
    if (!Utils.isString(postId)) {
      return reject(new Error('Invalid value for argument "postId". Must be string value'));
    }

    if (!pb.authStore?.model) {
      return reject(new Error("You need to be logged in to unlike a post"));
    }

    let hasLiked = await pb.collection("feed").getList(1, 1, {
      filter: 'type = "like" && author = "' + pb.authStore.model.id + '" && post = "' + postId + '"',
    });
    if (hasLiked.totalItems !== 1) {
      return reject(new Error("You haven't liked this post yet"));
    }

    pb.collection("feed")
      .delete(hasLiked.items[0].id)
      .then((res) => {
        pb.collection("posts")
          .update(postId, {
            "totalLikes-": 1,
          })
          .then((res) => resolve(res))
          .catch((err) => reject(err));
      })
      .catch((err) => reject(err));
  });
}

function repostPost(postId) {
  return new Promise(async (resolve, reject) => {
    if (!Utils.isString(postId)) {
      return reject(new Error('Invalid value for argument "postId". Must be string value'));
    }

    if (!pb.authStore?.model) {
      return reject(new Error("You need to be logged in to repost"));
    }

    let hasReposted = await pb.collection("feed").getList(1, 1, {
      filter: 'type = "repost" && author = "' + pb.authStore.model.id + '" && post = "' + postId + '"',
    });

    if (hasReposted.totalItems > 0) {
      return reject(new Error("You already reposted this post"));
    }

    pb.collection("feed")
      .create({
        type: "repost",
        author: pb.authStore.model.id,
        post: postId,
      })
      .then((res) => {
        pb.collection("posts")
          .update(postId, {
            "totalReposts+": 1,
          })
          .then((res) => resolve(res))
          .catch((err) => reject(err));
      })
      .catch((err) => reject(err));
  });
}

function removeRepost(postId) {
  return new Promise(async (resolve, reject) => {
    if (!Utils.isString(postId)) {
      return reject(new Error('Invalid value for argument "postId". Must be string value'));
    }

    if (!pb.authStore?.model) {
      return reject(new Error("You need to be logged in to remove a repost"));
    }

    let hasReposted = await pb.collection("feed").getList(1, 1, {
      filter: 'type = "repost" && author = "' + pb.authStore.model.id + '" && post = "' + postId + '"',
    });
    if (hasReposted.totalItems !== 1) {
      return reject(new Error("You haven't reposted this post yet"));
    }

    pb.collection("feed")
      .delete(hasReposted.items[0].id)
      .then((res) => {
        pb.collection("posts")
          .update(postId, {
            "totalReposts-": 1,
          })
          .then((res) => resolve(res))
          .catch((err) => reject(err));
      })
      .catch((err) => reject(err));
  });
}

function savePost(postId) {
  return new Promise(async (resolve, reject) => {
    if (!Utils.isString(postId)) {
      return reject(new Error('Invalid value for argument "postId". Must be string value'));
    }

    if (!pb.authStore?.model) {
      return reject(new Error("You need to be logged in to save"));
    }

    let savedPost = await pb.collection("saves").getList(1, 1, {
      filter: `feed = "${postId}" && user = "${pb.authStore.model.id}"`,
    });

    if (savedPost.totalItems !== 0) {
      return reject(new Error("You already saved this post"));
    }

    await pb
      .collection("saves")
      .create({
        feed: postId,
        user: pb.authStore.model.id,
      })
      .catch((err) => reject(err));
    pb.collection("feed")
      .update(postId, {
        "totalSaves+": 1,
      })
      .then((res) => resolve(res))
      .catch((err) => reject(err));
  });
}

function unsavePost(postId) {
  return new Promise(async (resolve, reject) => {
    if (!Utils.isString(postId)) {
      return reject(new Error('Invalid value for argument "postId". Must be string value'));
    }

    if (!pb.authStore?.model) {
      return reject(new Error("You need to be logged in to save"));
    }

    let savedPost = await pb.collection("saves").getList(1, 1, {
      filter: `feed = "${postId}" && user = "${pb.authStore.model.id}"`,
    });

    if (savedPost.totalItems === 0) {
      return reject(new Error("You don't have saved this post"));
    }

    await pb
      .collection("saves")
      .delete(savedPost.items[0].id)
      .catch((err) => reject(err));
    pb.collection("feed")
      .update(postId, {
        "totalSaves-": 1,
      })
      .then((res) => resolve(res))
      .catch((err) => reject(err));
  });
}

function getSaved(filter, pageSize = 20, pageOffset = 1) {
  return new Promise(async (resolve, reject) => {
    if (!Utils.isString(filter)) {
      return reject(new Error('Invalid value for argument "filter". Must be object value'));
    }

    let filterQuery = {};
    if (!filter) filterQuery.filter = [`(feed.type = 'post' || feed.type = 'repost')`];
    else if (filter === "replies") filterQuery.filter = [`(feed.type = 'post' || feed.type = 'repost' || feed.type = 'comment')`];
    else if (filter === "media") filterQuery.filter = [`(feed.type = 'post' || feed.type = 'repost' || feed.type = 'comment') && feed.post.images:length > 0`];
    else if (filter === "likes") filterQuery.filter = [`feed.type = 'like'`];

    let savedPosts = await pb
      .collection("saves")
      .getList(pageOffset, pageSize, {
        filter: [...filterQuery.filter, "feed.post.hidden = false"].join("&&"),
        sort: "-created",
      })
      .catch((err) => reject(err));

    if (savedPosts.totalItems === 0) {
      return resolve(savedPosts);
    }

    let feedPosts = await getAll(
      {
        filter: [`(${savedPosts.items.map((p) => `id = "${p.feed}"`).join(" || ")})`],
      },
      pageSize,
      1
    )
      .catch((err) => reject(err));

    let allPosts = []
    for (let post of savedPosts.items) {
      let index = feedPosts.items.findIndex(p => p.id === post.feed)
      allPosts.push(feedPosts.items[index])
    }
    feedPosts.items = allPosts
    return resolve(feedPosts)
  });
}

function trendingHashtags() {
  return new Promise((resolve, reject) => {
    pb.collection("hashtags")
      .getList(1, 20, {
        filter: "amount > 0",
        sort: "-amount",
      })
      .then((res) => resolve(res))
      .catch((err) => reject(err));
  });
}

function getTags(tags) {
  return new Promise((resolve, reject) => {
    if (!Utils.isObject(tags)) {
      return reject(new Error('Invalid value for argument "tags". Must be object value'));
    }

    pb.collection("hashtags")
      .getFullList(200, {
        filter: tags.map((t) => `name = "${t}"`).join(" || "),
        sort: "-amount",
      })
      .then((res) => resolve(res))
      .catch((err) => reject(err));
  });
}

function getPosts(filter, pageSize = 20, pageOffset = 1) {
  return new Promise(async (resolve, reject) => {
    if (!Utils.isObject(filter)) {
      return reject(new Error('Invalid value for argument "filter". Must be object value'));
    }

    let filterQuery = [...filter?.filter, "post.hidden = false"];

    let posts = await pb.collection("feed").getList(pageOffset, pageSize, {
      filter: filterQuery.join(" && ") || "",
      sort: filter?.sort || "",
      expand: "post,comment,author,post.author,comment.author",
    });

    if (posts.totalItems === 0) {
      return resolve(posts);
    }

    let uniquePosts = new Set();
    for (let p of posts.items) {
      uniquePosts.add(p.post);
    }
    let uniqueArray = [...uniquePosts];

    // let likes = await Promise.all(
    //   uniqueArray.map((p) => pb.collection("feed").getList(0, 1, { filter: `type = "like" && post.id = "${p}"`, $autoCancel: false }))
    // );
    // let comments = await Promise.all(
    //   uniqueArray.map((p) => pb.collection("feed").getList(0, 1, { filter: `type = "comment" && post.id = "${p}"`, $autoCancel: false }))
    // );
    // let reposts = await Promise.all(
    //   uniqueArray.map((p) => pb.collection("feed").getList(0, 1, { filter: `type = "repost" && post.id = "${p}"`, $autoCancel: false }))
    // );
    // // let saves = Promise.all([...uniquePosts].map(p => pb.collection("feed").getList(0,1, {filter: `type = "like" && post.id = "${p}"`, '$autoCancel': false}))).then(res => console.log(res))

    // posts.items.map(p => {
    //   let index = uniqueArray.indexOf(p.post)
    //   p.expand.post.totalLikes = likes[index].totalItems
    //   p.expand.post.totalComments = comments[index].totalItems
    //   p.expand.post.totalReposts = reposts[index].totalItems
    //   return p
    // })

    let didLike = false;
    let didRepost = false;
    let didSave = false;
    if (pb.authStore.isValid) {
      [didLike, didRepost, didSave] = await Promise.all([
        pb.collection("feed").getList(1, 20, {
          filter: `type = "like" && (${uniqueArray.map((p) => `post.id = "${p}"`).join(" || ")}) && author = "${pb.authStore.model.id}"`,
          $autoCancel: false,
        }),
        pb.collection("feed").getList(1, 20, {
          filter: `type = "repost" && (${uniqueArray.map((p) => `post.id = "${p}"`).join(" || ")}) && author = "${pb.authStore.model.id}"`,
          $autoCancel: false,
        }),
        pb.collection("saves").getList(1, pageSize, {
          filter: `(${posts.items.map((p) => `feed = "${p.id}"`).join(" || ")}) && user = "${pb.authStore?.model?.id}"`,
        }),
      ]);
    }

    posts.items.map((p) => {
      p.expand.post.didLike = pb.authStore.isValid ? didLike.items.some((i) => i.post === p.post) : false;
      p.expand.post.didRepost = pb.authStore.isValid ? didRepost.items.some((i) => i.post === p.post) : false;
      p.didSave = pb.authStore.isValid ? didSave.items.some((i) => i.feed === p.id) : false;
      return p;
    });

    return resolve(posts);
  });
}

export {
  addPost,
  getAll,
  getFollowingPosts,
  getSinglePost,
  getPostComments,
  likePost,
  unlikePost,
  repostPost,
  removeRepost,
  savePost,
  unsavePost,
  getSaved,
  trendingHashtags,
  getTags,
  hidePost,
};
