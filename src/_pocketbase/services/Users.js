// /*******************************************************************
// * Users.js
// * Generated by Backendless Corp.
// ********************************************************************/

import pb from "../connect";

const Utils = {
  isObject: (obj) => obj === Object(obj),
  isString: (obj) => Object.prototype.toString.call(obj).slice(8, -1) === "String",
  isNumber: (obj) => Object.prototype.toString.call(obj).slice(8, -1) === "Number",
  isBoolean: (obj) => Object.prototype.toString.call(obj).slice(8, -1) === "Boolean",
  isDate: (obj) => Object.prototype.toString.call(obj).slice(8, -1) === "Date",
};

async function signupUser(userInfo) {
  return new Promise((resolve, reject) => {
    if (!Utils.isObject(userInfo)) {
      return reject(new Error('Invalid value for argument "userInfo". Must be object value'));
    }

    if (!/^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i.test(userInfo.email)) {
      return reject(new Error("Provide a real address"));
    }

    if (userInfo.username.length > 0 && !/[^a-zA-Z0-9 ]/.test(userInfo.username) && !userInfo.username.match(/[ ]/g) && userInfo.username.match(/^.{4,20}$/g)) {
    } else {
      return reject(new Error("Provide a valid username"));
    }

    if (userInfo.password.length <= 0 || !userInfo.password.match(/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,20}$/g)) {
      return reject(new Error("Provida a valid password"));
    }

    userInfo.passwordConfirm = userInfo.password;
    userInfo.name = userInfo.username;

    pb.collection("users")
      .create(userInfo)
      .then((res) => resolve(res))
      .catch((e) => reject(e));
  });
}

async function editUser(updatedUser) {
  return new Promise((resolve, reject) => {
    if (!pb.authStore?.model) {
      return reject(new Error("You need to be logged in to edit"));
    }

    let upload = new FormData();

    if (updatedUser?.name) {
      upload.append("name", updatedUser.name);
    }
    if (updatedUser?.biography) {
      upload.append("biography", updatedUser.biography);
    }

    if (updatedUser?.avatar) {
      upload.append("avatar", "");
      upload.append("avatar", updatedUser.avatar);
    }

    if (updatedUser?.banner) {
      upload.append("banner", "");
      upload.append("banner", updatedUser.banner);
    }

    if (!Utils.isObject(updatedUser)) {
      return reject(new Error('Invalid value for argument "updatedUser". Must be object value'));
    }

    if (updatedUser?.name?.length > 30) {
      return reject(new Error("Name is too long"));
    }
    if (updatedUser?.name?.length === 0) {
      updatedUser.name = pb.authStore.model.username;
    }

    if (updatedUser?.biography?.length > 250) {
      return reject(new Error("Biography is too long"));
    }

    pb.collection("users")
      .update(updatedUser.id, upload)
      .then((res) => resolve(res))
      .catch((err) => reject(err));
  });
}

//   getFollowingUsers(userId) {
//     if (!Utils.isString(userId)) {
//       throw new Error('Invalid value for argument "userId". Must be string value')
//     }

//     const args = userId
//     return Backendless.APIServices.invoke('Users', 'getFollowingUsers', args)
//   },

//   getFollowedUsers(userId) {
//     if (!Utils.isString(userId)) {
//       throw new Error('Invalid value for argument "userId". Must be string value')
//     }

//     const args = userId
//     return Backendless.APIServices.invoke('Users', 'getFollowedUsers', args)
//   },

function followUser(userId) {
  return new Promise(async (resolve, reject) => {
    if (!Utils.isString(userId)) {
      return reject(new Error('Invalid value for argument "userId". Must be string value'));
    }

    if (!pb.authStore?.model) {
      return reject(new Error("You need to be logged in to followe"));
    }

    if (pb.authStore.model.id === userId) {
      return reject(new Error("You can't follow yourself"))
    }

    let curUser = await pb.collection("users").getOne(pb.authStore.model.id);
    if (curUser.follows.includes(userId)) {
      return reject(new Error("You already follow this account"));
    }

    Promise.all([
      pb.collection("users").update(pb.authStore.model.id, {
        "follows+": userId,
      }),
      pb.collection("users").update(userId, {
        "followers+": pb.authStore.model.id,
      }),
    ])
      .then((val) => {
        pb.collection("users").authRefresh();
        return resolve()
      })
      .catch((err) => reject(err));
  });
}

function unfollowUser(userId) {
  return new Promise(async (resolve, reject) => {
    if (!Utils.isString(userId)) {
      return reject(new Error('Invalid value for argument "userId". Must be string value'));
    }

    if (!pb.authStore?.model) {
      return reject(new Error("You need to be logged in to followe"));
    }

    if (pb.authStore.model.id === userId) {
      return reject(new Error("You can't unfollow yourself"))
    }

    let curUser = await pb.collection("users").getOne(pb.authStore.model.id);
    if (!curUser.follows.includes(userId)) {
      return reject(new Error("You don't follow this user"));
    }

    console.log(curUser)
    Promise.all([
      pb.collection("users").update(pb.authStore.model.id, {
        "follows-": userId,
      }),
      pb.collection("users").update(userId, {
        "followers-": pb.authStore.model.id,
      }),
    ])
      .then((val) => {
        pb.collection("users").authRefresh();
        return resolve()
      })
      .catch((err) => reject(err));
  });
}

function getSuggestedUsers() {
  return new Promise((resolve, reject) => {
    let userFilter = [];
    if (pb.authStore?.model?.follows?.length > 0) {
      userFilter = [...pb.authStore.model.follows];
    }
    userFilter = [...userFilter, pb.authStore.model.id].map((f) => `id != "${f}"`).join("&&");

    pb.collection("users")
      .getList(1, 3, {
        filter: userFilter,
        sort: "-followers:length",
      })
      .then((res) => resolve(res))
      .catch((err) => reject(err));
  });
}

function getAllUsers(filter, pageSize = 20, pageOffset = 1) {
  return new Promise((resolve, reject) => {
    if (!Utils.isObject(filter)) {
      return reject(new Error('Invalid value for argument "filter". Must be object value'));
    }

    pb.collection("users")
      .getList(pageOffset, pageSize, {
        filter: filter?.filter?.join("&&") || "",
        sort: filter.sort || "",
      })
      .then((res) => resolve(res))
      .catch((err) => reject(err));
  });
}

//   getSingleUser(username) {
//     if (!Utils.isString(username)) {
//       throw new Error('Invalid value for argument "username". Must be string value')
//     }

//     const args = username
//     return Backendless.APIServices.invoke('Users', 'getSingleUser', args)
//   },

//   getCurrentUser() {
//     const args = null

//     return Backendless.APIServices.invoke('Users', 'getCurrentUser', args)
//   },

//   resetPassword(email) {
//     if (!Utils.isString(email)) {
//       throw new Error('Invalid value for argument "email". Must be string value')
//     }

//     const args = email
//     return Backendless.APIServices.invoke('Users', 'resetPassword', args)
//   }
// }

export { signupUser, editUser, followUser, unfollowUser, getAllUsers, getSuggestedUsers };
